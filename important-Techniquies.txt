######## Hashing ###########
1. Two Sum whose sum is equal to target
    1.  let temp = targetSum - myArray[i]
    2. if(hashObj.contains(temp)){
            parisOfTwoSum.push(temp+","+myArray[i])
        } else {
            hashObj.add(myArray[k])
        }
2. Three Sum whose sum is equal to target
    1.  let first = myArray[i] for i=0
    2.  let second = myArray[j] for j=i+1
    3.  let temp = targetSum - (first+second)
    4. if(hashObj.contains(temp)){
            parisOfTwoSum.push(temp+","+first+","+second)
        } else {
            hashObj.add(myArray[j])
        }
3. Find Longest Sub array whose sum is equal to target 
    1. currentSum == Target {maxLength=Math.max(maxLength,i+1)} , 
    2. if( currentSum - Target ) {maxLength=Math.max(maxLength,i-get(currentSum - Target))}  
    3. if( !currentSum  )  {set((currentSum), 1)} 
4. Count no of sub array whose sum is equal to target
    1. currentSum == Target {res++} , 
    2. if( currentSum - Target ) {res +=  get(currentSum - Target) }  
    3. if( currentSum  ) {set((currentSum), get(currentSum)+1) } else {set((currentSum), 1)} 
3. Find Longest Sub array whose sum is equal to target 
    1. currentSum == Target {maxLength=Math.max(maxLength,i+1)} , 
    2. if( currentSum - Target ) {maxLength=Math.max(maxLength,i-get(currentSum - Target))}  
    3. if( !currentSum  )  {set((currentSum), 1)} 

######## Heap ###########
1. Kth Smallest in array (Max Heap)
    1. Add k element in Max Heap
    2. keep adding in max Heap if new elemnt is smaller than top element 
    3. in last k smaller values will  be there 
    4. print maxHeap[0]
2. Kth Largest in array  (Min Heap)
    1. Add k element in Min Heap
    2. keep adding in min Heap if new elemnt is greater than top element 
    3. in last k greater values will  be there 
    4. print minHeap[0]
3. Minimum product of k integer (Max Heap)
    1. Add k element in max Heap
    2. keep adding in max Heap if new elemnt is smaller than top element 
    3. in last k smaller values will  be there 
    4. multiply them 
4. Minimum Room for multiple metings (Min Heap)
    1. sort the array as per start time 
    2. Add first element's end time in min Heap
    2. keep removing top element in min Heap if new elemnt's start time  is greater than top element 
    2. keep adding in min Heap current element end time 
    3. in last print the length of min heap remaining elements that will be the maximum room used for that meetings 

######## Tree ###########

## Generic Tree ##
1. find min path sum in  tree 

## Binary Tree ##
1. Print Level Order traversing 
2. Print Left View Of Tree 
3. Print Right View Of Tree 
4. Print Height of tree 
5. find max path sum in binary tree 

## Binary Search Tree ##
1. BT to BST
2. Check BT is BST Or not ? 
3. Check BST contains dead end 
4. Print Height of tree 
5. find max path sum in binary tree 

######## Window Sliding ###########

######## Two Pointer ###########

######## Stack  ###########
######## Queue  ###########
######## Array  ###########
######## Strings  ###########

######## Recursion  ###########
######## DP  ###########
######## Backtracking  ###########

######## Greedy Method  ###########
1. minimum room (Min Heap + Greedy):- 
    1. sort via start time {agar next ane wala meeting ka start time agar purane ke end time se bada Ya Barabar he to Hum usi room me 
    meeting kar sakte he } (Min Heap Ka use karenge )
    2. print the min heap size that will be the Minimum Room Required 
2. minimum platform (Min Heap + Greedy):- 
    1. sort via start Arrival time {agar next ane wala train ka start time agar purane ke Departure time se bada Ya Barabar he to 
    Hum usi platform me train ko Ruka sakte he } (Min Heap Ka use karenge )
    2. print the min heap size that will be the Minimum Platform Required 
3. Maximum Activity selection  (No Heap Only Greedy):-
    1. sort via end time {jitni jaldi first activity end hogi utni jaldi hum dusri activity shuru kar payenge}
4. Maximum Profit As per deadlines given{Job Sequencing Problem}  (Via GreedyMethod ) O(N*N) Time Complexity: O(N2):-
    1. sort via Profit .
    2. choose max profit and setup them their Deadline day 
    3. If max profitable Job Deadline day is already filledup than find laser deadline day and setup their    
    Maximum Profit As per deadlines given{Job Sequencing Problem}  (Via Max Heap ) O(N) Time Complexity: O(N):-
    1. sort via Deadline .
    2. choose max Deadline in Max Heap 
    3. slot_Available = if(i>0) ? current element (deadline)  - previous element (deadline) : current element (deadline)
        if(slot_Available>0 && Heap in not empty){
            top = removeTop
            slot_Available--
            Result.push(top) 
        }
    4. sort Result as per deadline 
    5. print Result => obj.jobId
######## Graph  ###########

######## Searching   ###########
######## Sorting   ###########
    
