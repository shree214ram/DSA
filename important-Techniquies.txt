######## Hashing ###########
1. Two Sum whose sum is equal to target
    1.  let temp = targetSum - myArray[i]
    2. if(hashObj.contains(temp)){
            parisOfTwoSum.push(temp+","+myArray[i])
        } else {
            hashObj.add(myArray[k])
        }
2. Three Sum whose sum is equal to target
    1.  let first = myArray[i] for i=0
    2.  let second = myArray[j] for j=i+1
    3.  let temp = targetSum - (first+second)
    4. if(hashObj.contains(temp)){
            parisOfTwoSum.push(temp+","+first+","+second)
        } else {
            hashObj.add(myArray[j])
        }
3. Find Longest Sub array whose sum is equal to target 
    1. currentSum == Target {maxLength=Math.max(maxLength,i+1)} , 
    2. if( currentSum - Target ) {maxLength=Math.max(maxLength,i-get(currentSum - Target))}  
    3. if( !currentSum  )  {set((currentSum), 1)} 
4. Count no of sub array whose sum is equal to target
    1. currentSum == Target {res++} , 
    2. if( currentSum - Target ) {res +=  get(currentSum - Target) }  
    3. if( currentSum  ) {set((currentSum), get(currentSum)+1) } else {set((currentSum), 1)} 
3. Find Longest Sub array whose sum is equal to target 
    1. currentSum == Target {maxLength=Math.max(maxLength,i+1)} , 
    2. if( currentSum - Target ) {maxLength=Math.max(maxLength,i-get(currentSum - Target))}  
    3. if( !currentSum  )  {set((currentSum), 1)} 

######## Heap ###########
1. Kth Smallest in array (Max Heap)
    1. Add k element in Max Heap
    2. keep adding in max Heap if new elemnt is smaller than top element 
    3. in last k smaller values will  be there 
    4. print maxHeap[0]
2. Kth Largest in array  (Min Heap)
    1. Add k element in Min Heap
    2. keep adding in min Heap if new elemnt is greater than top element 
    3. in last k greater values will  be there 
    4. print minHeap[0]
3. Minimum product of k integer (Max Heap) 
    1. Add k element in max Heap
    2. keep adding in max Heap if new elemnt is smaller than top element 
    3. in last k smaller values will  be there 
    4. multiply them 
4. Minimum Room for multiple metings (Min Heap)
    1. sort the array as per start time 
    2. Add first element's end time in min Heap
    2. keep removing top element in min Heap if new elemnt's start time  is greater than top element 
    2. keep adding in min Heap current element end time 
    3. in last print the length of min heap remaining elements that will be the maximum room used for that meetings 

######## Tree ###########

## Generic Tree ##
1. find min path sum in  tree 

## Binary Tree ##
1. Print Level Order traversing 
2. Print Left View Of Tree 
3. Print Right View Of Tree 
4. Print Height of tree 
5. find max path sum in binary tree 

## Binary Search Tree ##
1. BT to BST
2. Check BT is BST Or not ? 
3. Check BST contains dead end 
4. Print Height of tree 
5. find max path sum in binary tree 

######## Greedy Method  ###########
1. minimum room (Min Heap + Greedy):- 
    1. sort via start time {agar next ane wala meeting ka start time agar purane ke end time se bada Ya Barabar he to Hum usi room me 
    meeting kar sakte he } (Min Heap Ka use karenge )
    2. print the min heap size that will be the Minimum Room Required 
2. minimum platform (Min Heap + Greedy):- 
    1. sort via start Arrival time {agar next ane wala train ka start time agar purane ke Departure time se bada Ya Barabar he to 
    Hum usi platform me train ko Ruka sakte he } (Min Heap Ka use karenge )
    2. print the min heap size that will be the Minimum Platform Required 
3. Maximum Activity selection  (No Heap Only Greedy):-
    1. sort via end time {jitni jaldi first activity end hogi utni jaldi hum dusri activity shuru kar payenge}
4. Maximum Profit As per deadlines given{Job Sequencing Problem}  (Via GreedyMethod ) O(N*N) Time Complexity: O(N2):-
    1. sort via Profit .
    2. choose max profit and setup them their Deadline day 
    3. If max profitable Job Deadline day is already filledup than find laser deadline day and setup their    
    Maximum Profit As per deadlines given{Job Sequencing Problem}  (Via Max Heap ) O(N) Time Complexity: O(N):-
    1. sort via Deadline .
    2. choose max Deadline in Max Heap 
    3. slot_Available = if(i>0) ? current element (deadline)  - previous element (deadline) : current element (deadline)
        if(slot_Available>0 && Heap in not empty){
            top = removeTop
            slot_Available--
            Result.push(top) 
        }
    4. sort Result as per deadline 
    5. print Result => obj.jobId
5. weighted-job-scheduling:- https://www.geeksforgeeks.org/weighted-job-scheduling can not use greedy because 
   1. there is no Deadline there 
   are start and end time with profit in {Job Sequencing Problem} :- Deadline and Profit was given 
   2. As like Activity selection there are start and end time But in this Problem {Profit is there }
   3. So this is the combination of Activity selection and Job Sequencing 
   [1. That will be done via Recursion {Max(Include current Job,Exclude current Job)}
    2. Or Dynamic Programming for optimal 
   ] 

######## Window Sliding ###########
1. fixed window sliding :-
    if we are traversing for fixed size window so 
    for(let i=0;i<A.length;i++){
        //window size m 
        for(let j=i;j<i+m-1 && i + m - 1 < A.length;j++)

       
    }
2. Dynamic Window sliding 
     //Dynamic Window 
        for (let j = i + 1; j < A.length - m + 1;) {
3. 

######## Two Pointer ###########
1. Array should be sorted 
######## Stack  ###########
1. Last In First Out 
######## Queue  ###########
1. First In First Out
######## DeQueue  ###########
1. Add and remove from both side .
######## Array  ###########
1. Kadane's Algo 
2. Commulative sum :- (comulativeSum[j]-comulativeSum[i]+A[i]) % 2 !=0 means It will increase counter1 
3. Find Duplicate :-
    1. Use array value as index 
        for (i = 0; i < size; i++) 
            { 
                if (arr[ Math.abs(arr[i])] >= 0) 
                    arr[ Math.abs(arr[i])] = -arr[ Math.abs(arr[i])]; 
                else
                    console.log(Math.abs(arr[i]) + " "); 
            }	
    ****But there is a problem in the above approach. It prints the repeated number more than once.****
    2. 	 Count the frequency 
        // count the frequency
        for (let i = 0; i < arr_size; i++) {
            Arr[Arr[i] % arr_size] = Arr[Arr[i] % arr_size] + arr_size;
        }
        document.write("The repeating elements are : " + "</br>");
        for (let i = 0; i < arr_size; i++) {
            if (Arr[i] >= arr_size * 2) {
                document.write(i + " " + "</br>");
            }
        }
######## Strings  ###########

######## Recursion  ###########
######## DP  ###########
######## Backtracking  ###########
######## Graph  ###########

######## Searching   ###########
1. Lenear Serch 
2. binary Search 
######## Sorting   ###########
1. selection sort 
2. bubble sort 
3. quick sort 
4. merge sort
5. heap sort 
    
