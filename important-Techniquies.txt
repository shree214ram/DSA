######## Hashing ###########
1. Two Sum whose sum is equal to target
    1.  let temp = targetSum - myArray[i]
    2. if(hashObj.contains(temp)){
            parisOfTwoSum.push(temp+","+myArray[i])
        } else {
            hashObj.add(myArray[k])
        }
2. Three Sum whose sum is equal to target
    1.  let first = myArray[i] for i=0
    2.  let second = myArray[j] for j=i+1
    3.  let temp = targetSum - (first+second)
    4. if(hashObj.contains(temp)){
            parisOfTwoSum.push(temp+","+first+","+second)
        } else {
            hashObj.add(myArray[j])
        }
3. Find Longest Sub array whose sum is equal to target 
    1. currentSum == Target {maxLength=Math.max(maxLength,i+1)} , 
    2. if( currentSum - Target ) {maxLength=Math.max(maxLength,i-get(currentSum - Target))}  
    3. if( !currentSum  )  {set((currentSum), 1)} 
4. Count no of sub array whose sum is equal to target
    1. currentSum == Target {res++} , 
    2. if( currentSum - Target ) {res +=  get(currentSum - Target) }  
    3. if( currentSum  ) {set((currentSum), get(currentSum)+1) } else {set((currentSum), 1)} 
3. Find Longest Sub array whose sum is equal to target 
    1. currentSum == Target {maxLength=Math.max(maxLength,i+1)} , 
    2. if( currentSum - Target ) {maxLength=Math.max(maxLength,i-get(currentSum - Target))}  
    3. if( !currentSum  )  {set((currentSum), 1)} 

######## Heap ###########
1. Kth Smallest in array (Max Heap)
    1. Add k element in Max Heap
    2. keep adding in max Heap if new elemnt is smaller than top element 
    3. in last k smaller values will  be there 
    4. print maxHeap[0]
2. Kth Largest in array  (Min Heap)
    1. Add k element in Min Heap
    2. keep adding in min Heap if new elemnt is greater than top element 
    3. in last k greater values will  be there 
    4. print minHeap[0]
3. Minimum product of k integer (Max Heap)
    1. Add k element in max Heap
    2. keep adding in max Heap if new elemnt is smaller than top element 
    3. in last k smaller values will  be there 
    4. multiply them 
4. Minimum Room for multiple metings (Min Heap)
    1. sort the array as per start time 
    2. Add first element's end time in min Heap
    2. keep removing top element in min Heap if new elemnt's start time  is greater than top element 
    2. keep adding in min Heap current element end time 
    3. in last print the length of min heap remaining elements that will be the maximum room used for that meetings 

######## Tree ###########

## Generic Tree ##
1. find min path sum in  tree 

## Binary Tree ##
1. Print Level Order traversing 
2. Print Left View Of Tree 
3. Print Right View Of Tree 
4. Print Height of tree 
5. find max path sum in binary tree 

## Binary Search Tree ##
1. BT to BST
2. Check BT is BST Or not ? 
3. Check BST contains dead end 
4. Print Height of tree 
5. find max path sum in binary tree 

######## Window Sliding ###########

######## Two Pointer ###########

######## Stack  ###########
######## Queue  ###########
######## Array  ###########
######## Strings  ###########

######## Recursion  ###########
######## DP  ###########
######## Backtracking  ###########

######## Greedy Method  ###########
######## Graph  ###########

######## Searching   ###########
######## Sorting   ###########
    
