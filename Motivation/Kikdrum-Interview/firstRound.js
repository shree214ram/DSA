[{start: <time1>, end: <endTime1>},
    {start: <time2>, end: <endTime2>},
    {start: <time3>, end: <endTime3>}]
    
    Time 1 : 1 pm end:2 pm  {Platform 1}
    Time 2: 1:30 end 2:30 {Platform 2}
    Time 3 3 end : 4pm  
    
    Display flights 
    
    We have to find the minimum 
    
    Sort the start time ascending order 
    Push the first train end time into Max Heap 
    If Start time of upcoming train is greater than To element of Max Heap
     {reuse the same row and update the MaxHeap Top with current element end time  }
    else {add new platform with end time }
    Max Heapify function will arrange automatically at top max element 
    
    Class MH(){
        constructor(){
            this.data=[]
    }
    add(){
    }
    maxHepify(){
    
    }
    }
    Const myArray = [{s:1,e:2},{s:1:30,e:2:30}{s:3,e:4}] - [{1,2}, {1:30, 2:30}, {2:01, 3:01}, {2:25,4pm}]
    [P1, p2 , p1 , p3]
    
    
    
            2:30 
            /
           /
        2
    myArray.sort((a,b)=>{})
    Const rows = []
    MH.add()
    while(!MH.empty()){
    
    }
    
    
    
    
    
    
    Draw a timeline
    Place the trains with appropriate widths
    
    
    
        export const MILLISECONDS_IN_A_DAY = 86400000;  //24hrs 
    export const MILLISECONDS_IN_AN_HOUR = 3600000; //1 hr
    export const MILLISECONDS_IN_A_MINUTE = 60000;  // 1min
    
        
    
        Const getDevicewidth = window.size (600px)
            
        Const 1hrPxWidth = parseInt(getDeviceWidth/12)
    
    
    [[t1, t2],[t3],[t4]]
    
        {
            P1:[{},{}],
            P2: [{}],
            P3 : [{}]
    }
        Return (){
        //Table header
        myArray.map((obj)=>{
            
    })
    
    myArray.map((obj)=>{
            //{s:1:30,e:2:30,startPx:milli(1:30)}
            Return (<div width={ennPX-startPX} style={{marginLeft:togeenratePxel}}><span style=”color:red”></div>
    )
    
    })
    
    }
    
        
        Function togeenratePxel(){
            Let start //1:30pm
            Let end //2:30pm 
            1px =  (3600000 * 12 )/600; //milisecond 
    
            1 millisecond = 1/(3600000 * 12 )/600;
            
    }
    For (){
    
    }
        start point : 
        0    
        12 am to 12 pm 
        12AM	1 ||||||||	2	3	4	5	6	6	8	9	10	11	12PM
    
                 |          |
                  
                     
    —-------Time —------
    
    —--P1
                            —----     —-------
    —---
    
    —--P2
        —----    
    —---
    
    —--P2
        —----    
    —---
    —--------------
    